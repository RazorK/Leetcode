1.Two Sums
主要是使用了java中的map，利用map.containsKey来代替一次遍历

2.Add Two Numbers
 * 1.特殊情况考虑 不同长度 进位
 * 2.result.next返回的使用
 * 3.对于==null的使用 引用和赋值都可以

3.Longest Substring
 * 1.容易的思路，遍历，在每次遍历中寻找以此为开头的最长字符串（可使用map）
 * 2.solution，map 的属性，put相同key则保留后者，利用这一属性，可实现一个扫描过程中key：key最大位置的map
 * 3. 利用map，维护了两个边界，一个范围


5.最长回文
/**
 * 自己编程中出现的问题：
 * s.substring(i,j)是取第i个字符到第j-1个字符 如（0，2） 是取0,1两个字符（j-i即length）
 * Created by aimin on 2017/5/9.
 */

 /**
 * 这里是推荐的做法，主要思路是只需要记录最长字符的开始位置和截止位置即可。
 * 更重要的地方：
 * 在遍历每个Char的时候，向外拓展，快速排除不合规则项
 * Created by aimin on 2017/5/9.
 */


6.
Z型重组字符串
StringBuilder
/**
 * Spot：StringBuilder 更快、更省资源地组合字符串
 * Created by aimin on 2017/5/23.
 */


7.
翻转整数
正负 越界
 /**
 * Spot： StringBuilder.reverse,Integer.MAX_VALUE&& Integer.MIN_VALUE
 * 我的解法： 使用字符串的翻转来实现，StringBuilder 的reverse函数可以实现
 * 问题： 首先没有检测翻转过后有没有超出界限
 * 优解： 从个位依次处理，超出界限或处理完毕返回
 * Created by aimin on 2017/7/15.
 */

8.
自己实现string2int

 /**
 * 带符号+, 带符号+-？？？？
 * 排除空格和首位0
 * 若出现多个符号则返回0
 * 处理数字时出现其他字符，则按字符前的数字返回
 * 首位数字出现后
 *
 * !!trim()直接去除空格
 *
 * 从前向后组合整数时，num*10+val， 判断使用Max/10来判断
 *
 * int 范围 负范围绝对值比正范围绝对值大一
 * Created by aimin on 2017/7/15.
 */


9.
判断数字回文

考虑字符串和数字的两种处理方法 负数不是回文
/**
 * 处理整数考虑溢出
 * Created by aimin on 2017/7/16.
 */

11.
最大的木桶容量
给予随机整数数组，将任意两值当作木板，求最大木桶容量

基本想法 两次遍历 O(n^2)

简单想法，两边向中间遍历， 移动较小值的指针

主要是找到简单的方法 要保证简单的方法能够遍历到目标选项

//理论证明
// 两边向中间遍历，每次向中间移动值较小的一边，一定能够遍历到面积最大的容器
// 不妨设 u>v>x>y  av, ax面积最大， 不妨设av>ax, 若au>av, 则aux>avx，矛盾;若ay>ax,则avy>avx，矛盾；所以一定可以包括avx

/**
 * 如何想到这个办法：
 * 首先，这个问题必须要遍历，目标在于如何更快地找到目标
 * 要省略掉没有必要的值 计算条件（更小的值*间隔） 目标两边其他的选择 间隔大，更小值一定会更小（由目标思考）
 * @param height
 * @return
 */

12.
Integer2Roman
整数转罗马数字  1~3999
罗马数字主要 转换关系如下
这里一开始没有考虑抽象一下，觉得直接各级if判断  写出来发现代码有点长
看了看网上资料 贪心算法

这里注意一下两个数组和一个hashmap的使用转换
/**
     * I  V  X  L   C    D    M
     * 1  5 10 50 100  500 1000
     *  IV  IX   XL   XC    CD   DCCC    CM
     *  4    9   40   90   400   800     900
     *
     * Created by aimin on 2017/7/16.
     */
13.
Roman2Integer
主要就是 如果较小数出现在较大数左边，则该较小数代表负 IV = 4 VI = 6


14.
Longgest Common Prefix
输入字符串数组 输出最长公共前缀
/**
 *
 * 首先 注意空串，空数组
 *
 * 利用java String 自带的函数indexOf，可判断字符串是否包括子串
 * 也可使用startsWith
 * Created by aimin on 2017/7/17.
 */


15.
3Sum  给出随机整数数组（正负） 找出所有不重复长度为3的和为0的数组（每个数只能用一次）
简单想法， 两次循环，用contains寻找第三个值， 插入结果前检测是否重复  结果超时
改进了一下，分类 按正负分两个数组，

建议解法，先排序 优点如下
/**
     * 重点 先排序 之后可以省去一次循环
     * 1.可以根据当前结果判断指针向哪个方向移动
     * 2.可以很快过滤重复值
     *
     * @param num
     * @return
     */

16.
3SumClosest 随机整数数组和目标值，找出不重复的三个数使三个数的和与target最接近，返回三数之和。

/**
 * 马虎犯错
 * 1.sum和target的距离与指针移动搞反
 * 2.记得赋初始值
 * 
 * 用的主要还是上一题的思路，先排序，一次遍历，根据条件进行二层遍历
 * Created by aimin on 2017/7/19.
 */

17.
/**
 * 题目，给手机按键，输入按键数字，返回可能输入的字符串
 * 想法很直白，首先根据第一个输入字符创建字符串，之后对每个输入的数字，先对字符串进行添加，再补充新的字符串
 * 
 * 注意，在循环体中对循环条件有改变的要着重考虑，如这里使用res.size()进行循环，在循环体重又有插入，则导致无限循环
 * 
 * 还有个小问题马虎了 在进行添加时，要注意是否是在原本的字符串上添加。。。
 * Created by aimin on 2017/7/21.
 */


18. 4Sum
/**
 * 题目 给出随机整数数组 和目标  选出所有不重复的和为目标的数字组合
 * Created by aimin on 2017/7/21.
 */
/**
     * 根据之前3Sum的做法，直接加一层循环就差不多，但是这里考虑重复情况比较复杂，直接在添加前进行重复检测
     */
/**
     * 这里通过限制合理地跳过相同项而不需要验证重复添加的过程
     * 所有合理情况必须只探讨一次，这个比较困难
     * 首先，要考虑清楚哪些地方可以跳过：
     * 在结果添加之后，跳过相同项hi lo
     * 对于i、j 相同项可以跳过，因为若需要重复i、j当前相同项的情况一定已讨论过
     * 对于hi lo未添加项，!!!不可以直接跳过之后重复项  因为有可能跳过合理情况
     * @param nums
     * @param target
     * @return
     */

19. Remove Nth Node From End of List

/**
 * 给出定义ListNode 删除List尾部第n个ListNode
 * 如：
 * Given linked list: 1->2->3->4->5, and n = 2.
 * return 1->2->3->5.
 * 主要注意边界情况下，操作和中间不同需要单独讨论
 * Created by aimin on 2017/7/22.
 */

20. 括号匹配

/**
 * 给出只包含()[]{}的字符串，判断该字符串是否符合括号规则，"(){}[]"、"{[()]}" 均属于正确规则
 * 使用栈就可以了
 * 其实可以直接使用char [] 自己实现栈的，这里还是做复杂了
 * 注意特殊情况 多出正括号时，不考虑会直接成功； 多出反括号时，栈可能会越界
 * Created by aimin on 2017/7/22.
 

21.整合两个已经排序的Listnode
 /**
     * 做这个问题最好画图，直接想象还是有点难，总是犯了这些错误：
     * 1.在插入的过程中，需要使用insert = isnert.next时与insert.next = nowPtr矛盾，一定要用temp记录
     * 2.总是忘记在插入之后before指针的移动
     * 3.之前代码写的非常繁琐是因为总是用.next!=null来判断结束，可以直接用!=null来判断
     * @param l1
     * @param l2
     * @return
     */

22. 生成括号
输入正整数n，生成所有合理的n个括号的组合 n=2 ()() (())
/**
 * 想了好长时间才想到递归。。  主要是之前没真正用递归解决过问题，想到这个问题可能会用堆栈或者二叉树，又去看了看算法书才想到
 * 要用递归主要是这种情况，有限分类，而且每个分类中都需要继续循环分类。。 例如遍历二叉树 例如这个
 *
 * 我想到用的这个方法主要是遍历了太多无效项，之后再将其排除， 应该在生成处排除比较好。
 * Created by aimin on 2017/7/23.
 */


24.
输入一串ListNode  将其每两个换位置 1-2-3-4-5 -> 2-1-4-3-5
/**
 * 这个不是很复杂，但是这个我做完耗时稍微久了一点
 * 看网上比较快的做法是虚构一个假的ListNode，然后开始 我的问题是判断语句比较多。。
 *
 * Created by aimin on 2017/7/25.
 */


26.

/**
 * 输入排序数组，删除重复数，并将数组前result项变为删除重复后数组
 * Created by aimin on 2017/7/25.
 */

/**
     * 我的做法里面 ptr可以用result代替呀。。
     * @param nums
     * @return
     */

27.
/**
 * 输入整数数组和整数val，移除整数数组中所有值为val的值并返回新数组
 * 
 * 审题出错。。  看成了返回删除的个数
 * Created by aimin on 2017/7/25.
 */

28.
/**
 * 主要注意边界检查，检查时应在haystack.length-needle.length处结束
 * Created by aimin on 2017/7/29.
 */

29.
不使用乘除法 实现除法
这里要注意边界 正负整数的最大值不同
//坑。。  Math.abs(Integer.MIN_VALUE) = Integer.MIN_VALUE 
//即math.abs对于int最小值做绝对值不会变成int最大值，而是维持int里负的最小值

最简单的方法，累减 超时
一种想法，每次翻倍除数，记录翻倍次数，类似二分地比较大小

magic numbers？

/**
     * 这里看了看网上的算法主要有两种，一是累加法x,2x,4x,8x,…… 如此累加
     * 还有一种魔方数的计算方法
     * 还是超时。。。
     * @param dividend
     * @param divisor
     * @return
     */
这里翻倍的做法 用递归可以不超时。。



31.
next permutation
输入一个数组，输出所有排列中，比这个排列较大的一个排列
/**
 * 23354 23534
 * 455432 52
 * 想法是从低到高 找到非递减排序的 然后把
 *
 * 出现的问题 一是length=1时未考虑，应考虑边界情况
 * 第二个问题 本来想不用分最大->最小情况的，但是貌似失败了
 * 第三个问题在判断是否继续时， > 和 >=不能等同，遇到时要考虑一下
 *
 * Created by aimin on 2017/8/17.
 */

/**
 * leetcode上最快的算法
 * 主要是利用了原序列末尾原本的递减序列，而非直接使用排序
 *
 * @param nums
 */

33.
/**
 * input: rotated array(1,2,3,4,5->4,5,1,2,3), target integer
 * output: index of the integer, -1 if not found
 *
 * Created by aimin on 2017/8/20.
 */

/**
* leetcode fastest algorithm
* dichotomy, divide into two parts until found the target
* @param nums
* @param target
* @return
*/


